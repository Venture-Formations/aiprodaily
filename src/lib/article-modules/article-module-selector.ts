import { supabaseAdmin } from '../supabase'
import type {
  ArticleModule,
  ArticleModuleCriteria,
  ArticleModulePrompt,
  ModuleArticle,
  IssueArticleModule,
  ArticleSelectionMode
} from '@/types/database'

interface ArticleSelectionResult {
  articles: ModuleArticle[]
  reason: string
}

interface CriteriaResult {
  criteria: ArticleModuleCriteria[]
  reason: string
}

interface PromptsResult {
  prompts: ArticleModulePrompt[]
  reason: string
}

export class ArticleModuleSelector {
  /**
   * Get all active article modules for a publication
   */
  static async getActiveModules(publicationId: string): Promise<ArticleModule[]> {
    const { data, error } = await supabaseAdmin
      .from('article_modules')
      .select('*')
      .eq('publication_id', publicationId)
      .eq('is_active', true)
      .order('display_order', { ascending: true })

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching modules:', error)
      return []
    }

    return (data || []) as ArticleModule[]
  }

  /**
   * Get a single article module by ID
   */
  static async getModule(moduleId: string): Promise<ArticleModule | null> {
    const { data, error } = await supabaseAdmin
      .from('article_modules')
      .select('*')
      .eq('id', moduleId)
      .single()

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching module:', error)
      return null
    }

    return data as ArticleModule
  }

  /**
   * Get criteria for a module
   */
  static async getModuleCriteria(moduleId: string): Promise<CriteriaResult> {
    const { data, error } = await supabaseAdmin
      .from('article_module_criteria')
      .select('*')
      .eq('article_module_id', moduleId)
      .eq('is_active', true)
      .order('criteria_number', { ascending: true })

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching criteria:', error)
      return { criteria: [], reason: 'Error fetching criteria' }
    }

    return {
      criteria: (data || []) as ArticleModuleCriteria[],
      reason: `Found ${data?.length || 0} active criteria`
    }
  }

  /**
   * Get prompts for a module (title and body)
   */
  static async getModulePrompts(moduleId: string): Promise<PromptsResult> {
    const { data, error } = await supabaseAdmin
      .from('article_module_prompts')
      .select('*')
      .eq('article_module_id', moduleId)

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching prompts:', error)
      return { prompts: [], reason: 'Error fetching prompts' }
    }

    return {
      prompts: (data || []) as ArticleModulePrompt[],
      reason: `Found ${data?.length || 0} prompts`
    }
  }

  /**
   * Get RSS feeds assigned to a module
   */
  static async getModuleFeeds(moduleId: string): Promise<string[]> {
    const { data, error } = await supabaseAdmin
      .from('rss_feeds')
      .select('id')
      .eq('article_module_id', moduleId)
      .eq('active', true)

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching feeds:', error)
      return []
    }

    return (data || []).map(f => f.id)
  }

  /**
   * Select top articles for a module based on score
   * This is the main selection method - gets posts from module's feeds,
   * ranked by total_score from post_ratings
   */
  static async selectArticlesForModule(
    module: ArticleModule,
    issueId: string,
    publicationId: string
  ): Promise<ArticleSelectionResult> {
    const selectionMode = module.selection_mode

    // Manual mode returns empty - admin must pick
    if (selectionMode === 'manual') {
      return { articles: [], reason: 'Manual selection required' }
    }

    // Get existing articles for this module/issue
    const { data: existingArticles, error: existingError } = await supabaseAdmin
      .from('module_articles')
      .select('*')
      .eq('issue_id', issueId)
      .eq('article_module_id', module.id)
      .eq('is_active', true)
      .order('rank', { ascending: true })

    if (existingError) {
      console.error('[ArticleModuleSelector] Error fetching existing articles:', existingError)
      return { articles: [], reason: 'Error fetching existing articles' }
    }

    if (existingArticles && existingArticles.length > 0) {
      return {
        articles: existingArticles as ModuleArticle[],
        reason: `Returning ${existingArticles.length} existing articles`
      }
    }

    // No existing articles - would need to be generated by workflow
    return {
      articles: [],
      reason: 'No articles generated yet - workflow must run first'
    }
  }

  /**
   * Initialize empty selections for an issue
   * Creates issue_article_modules entries for all active modules
   */
  static async initializeSelectionsForIssue(
    issueId: string,
    publicationId: string
  ): Promise<void> {
    // Check if selections already exist
    const { data: existing } = await supabaseAdmin
      .from('issue_article_modules')
      .select('article_module_id')
      .eq('issue_id', issueId)

    if (existing && existing.length > 0) {
      console.log('[ArticleModuleSelector] Selections already exist for issue:', issueId)
      return
    }

    // Get all active article modules
    const modules = await this.getActiveModules(publicationId)

    if (modules.length === 0) {
      console.log('[ArticleModuleSelector] No active article modules found')
      return
    }

    // Create empty selections for each module
    for (const module of modules) {
      await supabaseAdmin
        .from('issue_article_modules')
        .insert({
          issue_id: issueId,
          article_module_id: module.id,
          article_ids: [],
          selection_mode: module.selection_mode
        })
    }

    console.log(`[ArticleModuleSelector] Initialized ${modules.length} empty selections for issue ${issueId}`)
  }

  /**
   * Update article selections for a module after articles are generated
   */
  static async updateArticleSelections(
    issueId: string,
    moduleId: string,
    articleIds: string[]
  ): Promise<{ success: boolean; error?: string }> {
    const { error } = await supabaseAdmin
      .from('issue_article_modules')
      .upsert({
        issue_id: issueId,
        article_module_id: moduleId,
        article_ids: articleIds,
        selected_at: new Date().toISOString()
      }, {
        onConflict: 'issue_id,article_module_id'
      })

    if (error) {
      console.error('[ArticleModuleSelector] Error updating selections:', error)
      return { success: false, error: error.message }
    }

    console.log(`[ArticleModuleSelector] Updated selections: ${articleIds.length} articles for module ${moduleId}`)
    return { success: true }
  }

  /**
   * Manually select articles for a module (swap articles)
   */
  static async manuallySelectArticles(
    issueId: string,
    moduleId: string,
    articleIds: string[]
  ): Promise<{ success: boolean; error?: string }> {
    // First, deactivate all articles for this module/issue
    const { error: deactivateError } = await supabaseAdmin
      .from('module_articles')
      .update({ is_active: false, rank: null })
      .eq('issue_id', issueId)
      .eq('article_module_id', moduleId)

    if (deactivateError) {
      console.error('[ArticleModuleSelector] Error deactivating articles:', deactivateError)
      return { success: false, error: deactivateError.message }
    }

    // Activate selected articles with rank
    for (let i = 0; i < articleIds.length; i++) {
      const { error: activateError } = await supabaseAdmin
        .from('module_articles')
        .update({ is_active: true, rank: i + 1 })
        .eq('id', articleIds[i])
        .eq('issue_id', issueId)
        .eq('article_module_id', moduleId)

      if (activateError) {
        console.error('[ArticleModuleSelector] Error activating article:', activateError)
        return { success: false, error: activateError.message }
      }
    }

    // Update issue_article_modules
    await this.updateArticleSelections(issueId, moduleId, articleIds)

    return { success: true }
  }

  /**
   * Get article selections for an issue (for display on issue page)
   */
  static async getIssueArticleSelections(issueId: string): Promise<IssueArticleModule[]> {
    const { data, error } = await supabaseAdmin
      .from('issue_article_modules')
      .select(`
        *,
        article_module:article_modules(*)
      `)
      .eq('issue_id', issueId)
      .order('article_module(display_order)', { ascending: true })

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching issue selections:', error)
      return []
    }

    // For each selection, fetch the active articles
    const selectionsWithArticles = await Promise.all(
      (data || []).map(async (selection) => {
        const { data: articles } = await supabaseAdmin
          .from('module_articles')
          .select(`
            *,
            rss_post:rss_posts(
              *,
              post_ratings(
                total_score,
                criteria_1_score, criteria_1_reason, criteria_1_weight,
                criteria_2_score, criteria_2_reason, criteria_2_weight,
                criteria_3_score, criteria_3_reason, criteria_3_weight,
                criteria_4_score, criteria_4_reason, criteria_4_weight,
                criteria_5_score, criteria_5_reason, criteria_5_weight
              )
            )
          `)
          .eq('issue_id', issueId)
          .eq('article_module_id', selection.article_module_id)
          .eq('is_active', true)
          .order('rank', { ascending: true })

        return {
          ...selection,
          articles: articles || []
        }
      })
    )

    return selectionsWithArticles as IssueArticleModule[]
  }

  /**
   * Get all articles (active and inactive) for a module in an issue
   * Useful for showing article swapping options
   */
  static async getAllArticlesForModule(
    issueId: string,
    moduleId: string
  ): Promise<ModuleArticle[]> {
    const { data, error } = await supabaseAdmin
      .from('module_articles')
      .select(`
        *,
        rss_post:rss_posts(
          *,
          post_ratings(
            total_score,
            criteria_1_score, criteria_1_reason, criteria_1_weight,
            criteria_2_score, criteria_2_reason, criteria_2_weight,
            criteria_3_score, criteria_3_reason, criteria_3_weight,
            criteria_4_score, criteria_4_reason, criteria_4_weight,
            criteria_5_score, criteria_5_reason, criteria_5_weight
          )
        )
      `)
      .eq('issue_id', issueId)
      .eq('article_module_id', moduleId)
      .order('is_active', { ascending: false })
      .order('rank', { ascending: true, nullsFirst: false })

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching all articles:', error)
      return []
    }

    return (data || []) as ModuleArticle[]
  }

  /**
   * Record article usage at send time
   * Updates used_at timestamp on issue_article_modules
   */
  static async recordUsage(
    issueId: string,
    issueDate: Date
  ): Promise<{ success: boolean; recorded: number }> {
    const { data: selections, error } = await supabaseAdmin
      .from('issue_article_modules')
      .select('id')
      .eq('issue_id', issueId)
      .is('used_at', null)

    if (error || !selections) {
      console.error('[ArticleModuleSelector] Error fetching selections:', error)
      return { success: false, recorded: 0 }
    }

    // Mark all selections as used
    const { error: updateError } = await supabaseAdmin
      .from('issue_article_modules')
      .update({ used_at: new Date().toISOString() })
      .eq('issue_id', issueId)
      .is('used_at', null)

    if (updateError) {
      console.error('[ArticleModuleSelector] Error updating usage:', updateError)
      return { success: false, recorded: 0 }
    }

    console.log(`[ArticleModuleSelector] Recorded usage for ${selections.length} article modules`)
    return { success: true, recorded: selections.length }
  }

  /**
   * Activate top N articles by score for a module
   * Called during workflow finalization
   * Now includes minimum score filtering per criterion
   */
  static async activateTopArticles(
    issueId: string,
    moduleId: string,
    limit: number
  ): Promise<{ success: boolean; activated: number; skipped_reason?: string }> {
    // Get criteria with minimum enforcement enabled
    const { data: criteriaWithMinimums, error: criteriaError } = await supabaseAdmin
      .from('article_module_criteria')
      .select('criteria_number, minimum_score, enforce_minimum, name')
      .eq('article_module_id', moduleId)
      .eq('is_active', true)
      .eq('enforce_minimum', true)
      .not('minimum_score', 'is', null)

    if (criteriaError) {
      console.error('[ArticleModuleSelector] Error fetching criteria minimums:', criteriaError)
    }

    const minimumFilters = criteriaWithMinimums || []
    const hasMinimumFilters = minimumFilters.length > 0

    if (hasMinimumFilters) {
      console.log(`[ArticleModuleSelector] Minimum score filters active:`)
      minimumFilters.forEach(c => {
        console.log(`  - Criteria ${c.criteria_number} (${c.name}): minimum ${c.minimum_score}`)
      })
    }

    // Get all articles for this module/issue sorted by post rating
    const { data: articles, error } = await supabaseAdmin
      .from('module_articles')
      .select(`
        id,
        post_id,
        headline,
        content,
        fact_check_score
      `)
      .eq('issue_id', issueId)
      .eq('article_module_id', moduleId)
      .eq('skipped', false)
      .not('headline', 'is', null)
      .not('content', 'is', null)
      .gte('fact_check_score', 4) // Minimum fact check score

    if (error) {
      console.error('[ArticleModuleSelector] Error fetching articles for activation:', error)
      return { success: false, activated: 0 }
    }

    if (!articles || articles.length === 0) {
      console.log('[ArticleModuleSelector] No eligible articles to activate')
      return { success: true, activated: 0 }
    }

    // Get post ratings for sorting and filtering
    const postIds = articles.map(a => a.post_id).filter(Boolean)
    const { data: ratings } = await supabaseAdmin
      .from('post_ratings')
      .select(`
        post_id,
        total_score,
        criteria_1_score,
        criteria_2_score,
        criteria_3_score,
        criteria_4_score,
        criteria_5_score
      `)
      .in('post_id', postIds)

    // Create rating map (includes all criteria scores)
    const ratingMap = new Map<string, any>()
    ratings?.forEach(r => {
      if (r.post_id) ratingMap.set(r.post_id, r)
    })

    // Filter articles by minimum score criteria (AND logic - all must pass)
    let eligibleArticles = articles
    let failedMinimumCount = 0
    const failedCriteriaDetails: Record<string, number> = {}

    if (hasMinimumFilters) {
      eligibleArticles = articles.filter(article => {
        if (!article.post_id) return false

        const rating = ratingMap.get(article.post_id)
        if (!rating) return false

        // Check ALL minimum criteria (AND logic)
        for (const filter of minimumFilters) {
          const scoreKey = `criteria_${filter.criteria_number}_score` as keyof typeof rating
          const score = rating[scoreKey]

          if (score === null || score === undefined || score < filter.minimum_score) {
            failedMinimumCount++
            failedCriteriaDetails[filter.name] = (failedCriteriaDetails[filter.name] || 0) + 1
            return false // Article fails this criterion
          }
        }
        return true // Article passes all minimum criteria
      })

      console.log(`[ArticleModuleSelector] After minimum filtering: ${eligibleArticles.length}/${articles.length} articles eligible`)

      if (failedMinimumCount > 0) {
        console.log(`[ArticleModuleSelector] ${failedMinimumCount} articles failed minimum criteria:`)
        Object.entries(failedCriteriaDetails).forEach(([name, count]) => {
          console.log(`  - ${name}: ${count} failed`)
        })
      }
    }

    // Handle case where NO articles meet minimum requirements
    if (eligibleArticles.length === 0 && hasMinimumFilters) {
      const module = await this.getModule(moduleId)
      const moduleName = module?.name || 'Unknown'

      const failedCriteriaList = Object.entries(failedCriteriaDetails)
        .map(([name, count]) => `${name} (${count} failed)`)
        .join(', ')

      const warningMessage = `[WARNING] Section "${moduleName}" skipped: No articles met minimum score requirements. Failed criteria: ${failedCriteriaList}`

      console.warn(warningMessage)

      // Store warning in issue metrics for dashboard visibility
      const { data: issue } = await supabaseAdmin
        .from('publication_issues')
        .select('metrics')
        .eq('id', issueId)
        .single()

      const existingMetrics = (issue?.metrics as Record<string, any>) || {}
      const warnings = existingMetrics.minimum_score_warnings || []
      warnings.push({
        module_id: moduleId,
        module_name: moduleName,
        timestamp: new Date().toISOString(),
        total_articles: articles.length,
        failed_criteria: failedCriteriaDetails
      })

      await supabaseAdmin
        .from('publication_issues')
        .update({
          metrics: {
            ...existingMetrics,
            minimum_score_warnings: warnings
          }
        })
        .eq('id', issueId)

      return {
        success: true,
        activated: 0,
        skipped_reason: `No articles met minimum score requirements: ${failedCriteriaList}`
      }
    }

    // Sort eligible articles by total score
    const sortedArticles = [...eligibleArticles].sort((a, b) => {
      const scoreA = a.post_id ? (ratingMap.get(a.post_id)?.total_score || 0) : 0
      const scoreB = b.post_id ? (ratingMap.get(b.post_id)?.total_score || 0) : 0
      return scoreB - scoreA
    })

    // Deactivate all first
    await supabaseAdmin
      .from('module_articles')
      .update({ is_active: false, rank: null })
      .eq('issue_id', issueId)
      .eq('article_module_id', moduleId)

    // Activate top N
    const topArticles = sortedArticles.slice(0, limit)
    const articleIds: string[] = []

    for (let i = 0; i < topArticles.length; i++) {
      const { error: activateError } = await supabaseAdmin
        .from('module_articles')
        .update({ is_active: true, rank: i + 1 })
        .eq('id', topArticles[i].id)

      if (!activateError) {
        articleIds.push(topArticles[i].id)
      }
    }

    // Update issue_article_modules with selected IDs
    await this.updateArticleSelections(issueId, moduleId, articleIds)

    console.log(`[ArticleModuleSelector] Activated ${articleIds.length} articles for module ${moduleId}`)
    return { success: true, activated: articleIds.length }
  }
}
